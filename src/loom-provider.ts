import { Client, ClientEvent, IChainEventArgs } from './client'
import {
  CallTx,
  MessageTx,
  Transaction,
  VMType,
  EvmTxReceipt,
  Event,
  DeployTx,
  DeployResponse,
  DeployResponseData,
  Address as ProtoAddress
} from './proto/loom_pb'
import { Address, LocalAddress } from './address'
import {
  bytesToHexAddr,
  numberToHex,
  bufferToProtobufBytes,
  getGUID,
  B64ToUint8Array
} from './crypto-utils'

interface EthReceipt {
  transactionHash: string
  transactionIndex: string
  blockHash: string
  blockNumber: string
  gasUsed: string
  cumulativeGasUsed: string
  contractAddress: string
  logs: Array<any>
  status: string
}

const bytesToHexAddrLC = (bytes: Uint8Array): string => {
  return bytesToHexAddr(bytes).toLowerCase()
}

const numberToHexLC = (num: number): string => {
  return numberToHex(num).toLowerCase()
}

/**
 * Web3 provider that interacts with EVM contracts deployed on Loom DAppChains.
 */
export class LoomProvider {
  private _client: Client
  private _connection?: WebSocket
  private _topicsList: Array<string>
  private _deployedCodes: any
  private _accounts: Array<string>
  protected notificationCallbacks: Array<Function>

  /**
   * @param client: The client which calls Ethereum EVM
   */
  constructor(client: Client) {
    this.notificationCallbacks = new Array()
    this._deployedCodes = new Object()
    this._accounts = new Array()
    this._client = client
    this._topicsList = []
    this._client.addListener(ClientEvent.Contract, (msg: IChainEventArgs) =>
      this._onWebSocketMessage(msg)
    )
    this.addDefaultEvents()
  }

  addAccounts(accounts: string | Array<string>):void {
    if (Array.isArray(accounts)) {
      this._accounts = this._accounts.concat(accounts)
    } else {
      this._accounts.push(accounts)
    }
  }

  on(type: string, callback: any) {
    switch (type) {
      case 'data':
        this.notificationCallbacks.push(callback)
        break
      case 'connect':
        this._client.addListener(ClientEvent.Connected, callback)
        break
      case 'end':
        this._client.addListener(ClientEvent.Disconnected, callback)
        break
      case 'error':
        this._client.addListener(ClientEvent.Error, callback)
        break
    }
  }

  addDefaultEvents() {
    this._client.addListener(ClientEvent.Disconnected, () => {
      // reset all requests and callbacks
      this.reset()
    })
  }

  removeListener(type: string, callback: (...args: any[]) => void) {
    switch (type) {
      case 'data':
        this.notificationCallbacks = []
        break
      case 'connect':
        this._client.removeListener(ClientEvent.Connected, callback)
        break
      case 'end':
        this._client.removeListener(ClientEvent.Disconnected, callback)
        break
      case 'error':
        this._client.removeListener(ClientEvent.Error, callback)
        break
    }
  }

  removeAllListeners(type: string, callback: Function) {
    if (type === 'data') {
      this.notificationCallbacks.forEach((cb, index) => {
        if (cb === callback) {
          this.notificationCallbacks.splice(index, 1)
        }
      })
    }
  }

  reset() {
    this._topicsList = []
    this.notificationCallbacks = []
  }

  disconnect() {
    this._client.disconnect()
  }

  // Adapter function for sendAsync from truffle provider
  async sendAsync(payload: any, callback: Function) {
    await this.send(payload, callback)
  }

  /**
   * Should be used to make async request
   * This method is used internally by web3, so we adapt it to be used with loom contract
   * when we are wrapping the evm on a DAppChain
   * @param payload JSON payload generated by web3 which will be translated to loom transaction/call
   * @param callback Triggered on end with (err, result)
   */
  async send(payload: any, callback: Function) {
    const isArray = Array.isArray(payload)
    if (isArray) {
      payload = payload[0]
    }

    // Methods frequently called by web3js added just to follow the web3 requirements
    const okMethods = ['eth_estimateGas', 'eth_gasPrice', 'eth_blockNumber']

    /**
     * NOTE: _okResponse and okMethods array are mocks, only to allow web3js think that is talking
     * to an Ethereum Node
     */

    // Ok just avoids web3js issues
    if (okMethods.indexOf(payload.method) !== -1) {
      return callback(null, this._okResponse(payload.id, null, isArray))
    }

    switch (payload.method) {
      case 'net_version':
        // Fixed network version 474747
        callback(null, this._okResponse(payload.id, '474747', isArray))
        break
      case 'eth_accounts':
        // TODO: Should return some real account from loom
        const accounts = this._accounts.length > 0 ? this._accounts : ['0x0000000000000000000000000000000000000000']
        callback(null, this._okResponse(payload.id, accounts))
        break
      case 'eth_newBlockFilter':
        // Simulate subscribe for new block filter
        callback(null, this._okResponse(payload.id, '0x01', isArray))
        break
      case 'eth_getBlockByNumber':
        // Simulate get block by number
        callback(null, this._okResponse(payload.id, this._simulateEmptyBlock(), isArray))
        break
      case 'eth_getFilterChanges':
        // Simulate return from block filter
        callback(null, [
          this._okResponse(payload.id, [
            '0x0000000000000000000000000000000000000000000000000000000000000001'
          ])
        ])
        break
      case 'eth_sendTransaction':
        // Sending transaction to Loom DAppChain
        try {
          let result

          if (payload.params[0].to) {
            result = await this._callAsync(payload.params[0])
          } else {
            result = await this._deployAsync(payload.params[0])
          }

          callback(null, this._okResponse(payload.id, bytesToHexAddrLC(result), isArray))
        } catch (err) {
          callback(err, null)
        }
        break
      case 'eth_getCode':
        // Simulate the get code
        callback(null, this._okResponse(payload.id, this._deployedCodes[payload.params[0]], isArray))
        break
      case 'eth_call':
        // Sending a static call to Loom DAppChain
        try {
          const result = await this._callStaticAsync(payload.params[0])
          callback(null, this._okResponse(payload.id, bytesToHexAddrLC(result), isArray))
        } catch (err) {
          callback(err, null)
        }
        break
      case 'eth_getTransactionReceipt':
        try {
          const result = await this._getReceipt(payload.params[0])
          callback(null, this._okResponse(payload.id, result, isArray))
        } catch (err) {
          callback(err, null)
        }
        break
      case 'eth_subscribe':
        // Required to avoid web3js error, because web3js always want to know about a transaction
        if (payload.params[0] === 'logs') {
          this._topicsList = this._topicsList.concat(payload.params[1].topics)
          callback(null, this._okResponse(payload.params[1].topics[0], isArray))
        } else {
          callback(null, this._okResponse(payload.id, isArray))
        }
        break
      case 'eth_uninstallFilter':
        callback(null, this._okResponse(payload.id, true, isArray))
        break
      default:
        // Warn the user about we don't support other methods
        callback(Error(`Method "${payload.method}" not supported on this provider`), null)
        break
    }
  }

  private _deployAsync(payload: { from: string; data: string }): Promise<any> {
    const caller = new Address(this._client.chainId, LocalAddress.fromHexString(payload.from))
    const address = new Address(
      this._client.chainId,
      LocalAddress.fromHexString('0x0000000000000000000000000000000000000000')
    )

    const data = Buffer.from(payload.data.substring(2), 'hex')

    const deployTx = new DeployTx()
    deployTx.setVmType(VMType.EVM)
    deployTx.setCode(bufferToProtobufBytes(data))

    const msgTx = new MessageTx()
    msgTx.setFrom(caller.MarshalPB())
    msgTx.setTo(address.MarshalPB())
    msgTx.setData(deployTx.serializeBinary())

    const tx = new Transaction()
    tx.setId(1)
    tx.setData(msgTx.serializeBinary())

    return this._client.commitTxAsync<Transaction>(tx).then(ret => {
      const response = DeployResponse.deserializeBinary(bufferToProtobufBytes(ret as Uint8Array))
      const address = bytesToHexAddrLC(
        (response.getContract() as ProtoAddress).getLocal() as Uint8Array
      )

      const responseData = DeployResponseData.deserializeBinary(bufferToProtobufBytes(response.getOutput_asU8()))
      this._deployedCodes[address] = bytesToHexAddrLC(responseData.getBytecode_asU8())
      return responseData.getTxHash_asU8()
    })
  }

  private _callAsync(payload: { to: string; from: string; data: string }): Promise<any> {
    const caller = new Address(this._client.chainId, LocalAddress.fromHexString(payload.from))
    const address = new Address(this._client.chainId, LocalAddress.fromHexString(payload.to))
    const data = Buffer.from(payload.data.substring(2), 'hex')

    const callTx = new CallTx()
    callTx.setVmType(VMType.EVM)
    callTx.setInput(bufferToProtobufBytes(data))

    const msgTx = new MessageTx()
    msgTx.setFrom(caller.MarshalPB())
    msgTx.setTo(address.MarshalPB())
    msgTx.setData(callTx.serializeBinary())

    const tx = new Transaction()
    tx.setId(2)
    tx.setData(msgTx.serializeBinary())

    return this._client.commitTxAsync<Transaction>(tx)
  }

  private _callStaticAsync(payload: { to: string; data: string }): Promise<any> {
    const address = new Address(this._client.chainId, LocalAddress.fromHexString(payload.to))
    const data = Buffer.from(payload.data.substring(2), 'hex')
    return this._client.queryAsync(address, data, VMType.EVM)
  }

  private async _getReceipt(txHash: string): Promise<EthReceipt> {
    const data = Buffer.from(txHash.substring(2), 'hex')
    const receipt = await this._client.getTxReceiptAsync(bufferToProtobufBytes(data))

    if (!receipt) {
      throw Error('Receipt cannot be empty')
    }

    const transactionHash = '0x0000000000000000000000000000000000000000000000000000000000000000'
    const transactionIndex = numberToHexLC(receipt.getTransactionIndex())
    const blockHash = bytesToHexAddrLC(receipt.getBlockHash_asU8())
    const blockNumber = numberToHexLC(receipt.getBlockNumber())
    const contractAddress = bytesToHexAddrLC(receipt.getContractAddress_asU8())

    const logs = receipt.getLogsList().map((logEvent: Event, index: number) => {
      const logIndex = numberToHexLC(index)

      return {
        logIndex,
        address: contractAddress,
        blockHash,
        blockNumber,
        transactionHash,
        transactionIndex,
        type: 'mined',
        data: bytesToHexAddrLC(logEvent.getData_asU8()),
        topics: logEvent
          .getTopicsList_asU8()
          .map((topic: Uint8Array) => bytesToHexAddrLC(topic))
      }
    })

    return {
      transactionHash,
      transactionIndex,
      blockHash,
      blockNumber,
      contractAddress,
      gasUsed: numberToHexLC(receipt.getGasUsed()),
      cumulativeGasUsed: numberToHexLC(receipt.getCumulativeGasUsed()),
      logs,
      status: numberToHexLC(receipt.getStatus())
    } as EthReceipt
  }

  protected _onWebSocketMessage(msgEvent: IChainEventArgs) {
    if (msgEvent.data) {
      const event = Event.deserializeBinary(bufferToProtobufBytes(msgEvent.data))
      this.notificationCallbacks.forEach((callback: Function) => {
        const topics = event
          .getTopicsList_asU8()
          .map((topic: Uint8Array) => bytesToHexAddrLC(topic))
        const topicIdxFound = this._topicsList.indexOf(topics[0])

        if (topicIdxFound !== -1) {
          const topicFound = this._topicsList[topicIdxFound]
          const JSONRPCResult = {
            jsonrpc: '2.0',
            method: 'eth_subscription',
            params: {
              // TODO: This ID Should came from loomchain events
              subscription: topicFound,
              result: {
                // TODO: Values bellow should be fix in the future
                logIndex: '0x00',
                transactionIndex: '0x00',
                transactionHash:
                  '0x0000000000000000000000000000000000000000000000000000000000000000',
                blockHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
                blockNumber: '0x0',
                address: '0x0000000000000000000000000000000000000000',
                type: 'mined',
                data: bytesToHexAddrLC(event.getData_asU8()),
                topics
              }
            }
          }

          callback(JSONRPCResult)
        }
      })
    }
  }

  protected _simulateEmptyBlock(block: any = {}) {
    return Object.assign({
      number: '0x0',
      hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
      parentHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
      mixHash: '0x1010101010101010101010101010101010101010101010101010101010101010',
      nonce: '0x0000000000000000',
      sha3Uncles: '0x0000000000000000000000000000000000000000000000000000000000000000',
      logsBloom:
        '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
      transactionsRoot: '0x0000000000000000000000000000000000000000000000000000000000000000',
      stateRoot: '0x0000000000000000000000000000000000000000000000000000000000000000',
      receiptsRoot: '0x0000000000000000000000000000000000000000000000000000000000000000',
      miner: '0x0000000000000000000000000000000000000000',
      difficulty: '0x0',
      totalDifficulty: '0x0',
      extraData: '0x00',
      size: '0x0',
      gasLimit: '0x0',
      gasUsed: '0x0',
      timestamp: '0x0',
      transactions: []
    }, block)
  }

  // Basic response to web3js
  private _okResponse(id: string, result: any = 0, isArray = false): any {
    const response = { id, jsonrpc: '2.0', result }
    const ret = isArray ? [response] : response
    return ret
  }
}
