import { Client } from './client'
import { CallTx, MessageTx, Transaction, VMType, EvmTxReceipt, Event } from './proto/loom_pb'
import { Address, LocalAddress } from './address'
import { bytesToHexAddr, numberToHex, bufferToProtobufBytes, getGUID } from './crypto-utils'

interface EthReceipt {
  transactionHash: string
  transactionIndex: string
  blockHash: string
  blockNumber: string
  gasUsed: string
  cumulativeGasUsed: string
  contractAddress: string
  logs: Array<any>
  status: string
}

const errors = {
  ErrorResponse: function (result: any) {
    const message = !!result && !!result.error && !!result.error.message ? result.error.message : JSON.stringify(result);
    return new Error('Returned error: ' + message);
  },
  InvalidNumberOfParams: function (got: any, expected: any, method: any) {
    return new Error('Invalid number of parameters for "'+ method +'". Got '+ got +' expected '+ expected +'!');
  },
  Invalid_Connection: function (host: any) {
    return new Error('_CONNECTION ERROR: Couldn\'t connect to node '+ host +'.');
  },
  InvalidProvider: function () {
    return new Error('Provider not set or invalid');
  },
  InvalidResponse: function (result: any) {
    const message = !!result && !!result.error && !!result.error.message ? result.error.message : 'Invalid JSON RPC response: ' + JSON.stringify(result);
    return new Error(message);
  },
  _ConnectionTimeout: function (ms: any) {
    return new Error('_CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');
  }
}

/**
 * Web3 provider that interacts with EVM contracts deployed on Loom DAppChains.
 */
export class LoomProvider {
  private _client: Client
  private _connection?: WebSocket
  private _subscriptionID: string
  private _topicsList: Array<string>
  protected notificationCallbacks: Array<Function>
  protected responseCallbacks: any

  /**
   * @param client: The client which calls Ethereum EVM
   */
  constructor(client: Client) {
    this.notificationCallbacks = new Array()
    this._client = client
    this._subscriptionID = getGUID()
    this._topicsList = []
    this._subscribeWS(client.readUrl)
  }

  on(type: string, callback: any) {
    if (!this._connection) return

    switch(type) {
      case 'data':
          this.notificationCallbacks.push(callback);
          break;

      case 'connect':
          this._connection.onopen = callback;
          break;

      case 'end':
          this._connection.onclose = callback;
          break;

      case 'error':
          this._connection.onerror = callback;
          break;
    }
  }

  addDefaultEvents() {
    if (!this._connection) return

    this._connection.onerror = () => this._timeout()
    this._connection.onclose = () => {
        this._timeout()
        // reset all requests and callbacks
        this.reset();
    };
  }

  removeListener() {
    this.reset()
  }

  removeAllListeners(type: any) {
    this.reset()
  }

  reset() {
    this._topicsList = []
    this.notificationCallbacks = []
  }

  /**
   * Should be used to make async request
   * This method is used internally by web3, so we adapt it to be used with loom contract
   * when we are wrapping the evm on a DAppChain
   * @param payload JSON payload generated by web3 which will be translated to loom transaction/call
   * @param callback Triggered on end with (err, result)
   */
  async send(payload: any, callback: Function) {
    // Methods frequently called by web3js added just to follow the web3 requirements
    const okMethods = ['eth_estimateGas', 'eth_gasPrice']

    /**
     * NOTE: _okResponse and okMethods array are mocks, only to allow web3js think that is talking
     * to an Ethereum Node
     */

    // Ok just avoids web3js issues
    if (okMethods.indexOf(payload.method) !== -1) {
      callback(null, this._okResponse())
    }

    // Sending transaction to Loom DAppChain
    else if (payload.method === 'eth_sendTransaction') {
      try {
        const result = await this._callAsync(payload.params[0])
        callback(null, this._okResponse(bytesToHexAddr(result)))
      } catch (err) {
        callback(err, null)
      }
    }

    // Sending a static call to Loom DAppChain
    else if (payload.method === 'eth_call') {
      try {
        const result = await this._callStaticAsync(payload.params[0])
        callback(null, this._okResponse(bytesToHexAddr(result)))
      } catch (err) {
        callback(err, null)
      }
    }

    // Required to avoid web3js error, because web3js always want to know about a transaction
    else if (payload.method === 'eth_getTransactionReceipt') {
      try {
        const result = await this._getReceipt(payload.params[0])
        callback(null, this._okResponse(result))
      } catch (err) {
        callback(err, null)
      }
    }

    else if (payload.method === 'eth_subscribe') {
      if (payload.params[0] === 'logs') {
        this._topicsList = this._topicsList.concat(payload.params[1].topics)
        callback(null, this._okResponse(payload.params[1].topics[0]))
      } else {
        callback(null, this._okResponse())
      }
    }

    // Warn the user about we don't support other methods
    else {
      callback(Error(`Method "${payload.method}" not supported on this provider`), null)
    }
  }

  private _callAsync(payload: { to: string; from: string; data: string }): Promise<any> {
    const caller = new Address(this._client.chainId, LocalAddress.fromHexString(payload.from))
    const address = new Address(this._client.chainId, LocalAddress.fromHexString(payload.to))
    const data = Buffer.from(payload.data.substring(2), 'hex')

    const callTx = new CallTx()
    callTx.setVmType(VMType.EVM)
    callTx.setInput(bufferToProtobufBytes(data))

    const msgTx = new MessageTx()
    msgTx.setFrom(caller.MarshalPB())
    msgTx.setTo(address.MarshalPB())
    msgTx.setData(callTx.serializeBinary())

    const tx = new Transaction()
    tx.setId(2)
    tx.setData(msgTx.serializeBinary())

    return this._client.commitTxAsync<Transaction>(tx)
  }

  private _callStaticAsync(payload: { to: string; data: string }): Promise<any> {
    const address = new Address(this._client.chainId, LocalAddress.fromHexString(payload.to))
    const data = Buffer.from(payload.data.substring(2), 'hex')
    return this._client.queryAsync(address, data, VMType.EVM)
  }

  private async _getReceipt(txHash: string): Promise<EthReceipt> {
    const data = Buffer.from(txHash.substring(2), 'hex')
    const receipt = await this._client.getTxReceiptAsync(bufferToProtobufBytes(data))

    if (!receipt) {
      throw Error('Receipt cannot be empty')
    }

    const transactionHash = '0x0000000000000000000000000000000000000000000000000000000000000000'
    const transactionIndex = numberToHex(receipt.getTransactionIndex())
    const blockHash = bytesToHexAddr(receipt.getBlockHash_asU8())
    const blockNumber = numberToHex(receipt.getBlockNumber())
    const contractAddress = bytesToHexAddr(receipt.getContractAddress_asU8())

    const logs = receipt.getLogsList().map((logEvent: Event, index: number) => {
      const logIndex = numberToHex(index)

      return {
        logIndex,
        address: contractAddress,
        blockHash,
        blockNumber,
        transactionHash,
        transactionIndex,
        type: 'mined',
        data: bytesToHexAddr(logEvent.getData_asU8()).toLowerCase(),
        topics: logEvent.getTopicsList_asU8().map((topic: Uint8Array) => bytesToHexAddr(topic).toLowerCase())
      }
    })

    return {
      transactionHash,
      transactionIndex,
      blockHash,
      blockNumber,
      contractAddress,
      gasUsed: numberToHex(receipt.getGasUsed()),
      cumulativeGasUsed: numberToHex(receipt.getCumulativeGasUsed()),
      logs,
      status: numberToHex(receipt.getStatus()),
    } as EthReceipt
  }

  protected _subscribeWS(readUrl?: string) {
    if (readUrl) {
      if (typeof window !== 'undefined') {
        this._connection = new WebSocket(readUrl)
      } else {
        const WS = require('websocket').w3cwebsocket
        this._connection = new WS(readUrl)
      }

      if (!this._connection) return


      this._connection.onopen = () => {
        if (!this._connection) return
        this._connection.send(JSON.stringify({
          method: 'subevents',
          jsonrpc: '2.0',
          params: [],
          id: this._subscriptionID
        }))

        this._connection.onmessage = (msg: MessageEvent) => this._onWebSocketMessage(msg)
      }
    }
  }

  protected _onWebSocketMessage(msgEvent: MessageEvent) {
    const data = JSON.parse(msgEvent.data)
    const encodedData = data.result.encodedData
    if (encodedData) {
      const event = Event.deserializeBinary(encodedData)
      this.notificationCallbacks.forEach((callback: Function) => {
        const topics = event.getTopicsList_asU8().map((topic: Uint8Array) => bytesToHexAddr(topic).toLowerCase())
        const topicIdxFound = this._topicsList.indexOf(topics[0])

        if (topicIdxFound !== -1) {
          const topicFound = this._topicsList[topicIdxFound]
          const JSONRPCResult = {
            jsonrpc: "2.0",
            method: "eth_subscription",
            params: {
              // TODO: This ID Should came from loomchain events
              subscription: topicFound,
              result: {
                // TODO: Values bellow should be fix in the future
                logIndex: '0x00',
                transactionIndex: '0x00',
                transactionHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
                blockHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
                blockNumber: '0x0',
                address: '0x0000000000000000000000000000000000000000',
                type: 'mined',
                data: bytesToHexAddr(event.getData_asU8()).toLowerCase(),
                topics
              }
            }
          }

          callback(JSONRPCResult)
        }
      })
    }
  }

  protected _timeout() {
    for(let key in this.responseCallbacks) {
      if(this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors.Invalid_Connection('on WS'));
          delete this.responseCallbacks[key];
      }
    }
  }

  // Basic response to web3js
  private _okResponse(result: any = 0): any {
    return { id: 0, jsonrpc: '2.0', result }
  }
}
