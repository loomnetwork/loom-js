import test from 'tape'
import BN from 'bn.js'
import Web3 from 'web3'

import {
  LocalAddress,
  Address,
  EthereumPlasmaClient,
  DAppChainPlasmaClient,
  PlasmaCashTx,
  CryptoUtils,
  NonceTxMiddleware,
  SignedTxMiddleware,
  Web3Signer,
  EthErc721Contract
} from '../../index'
import { createTestHttpClient } from '../helpers'

let web3: Web3

// Alice registers and has 5 coins, and she deposits 3 of them.
const ALICE_INITIAL_COINS = 5
const ALICE_DEPOSITED_COINS = 3
const COINS = [1, 2, 3]
const DEFAULT_GAS = '3141592'
const CHILD_BLOCK_INTERVAL = 1000

// TODO: these should be pulled out of a config file generated by a Truffle migration
const ADDRESSES = {
  validator_manager: '0xf5cad0db6415a71a5bc67403c87b56b629b4ddaa',
  root_chain: '0x9e51aeeeca736cd81d27e025465834b8ec08628a',
  token_contract: '0x1aa76056924bf4768d63357eca6d6a56ec929131'
}

// TODO: these should be pulled out of a config file generated by a Truffle migration
const ACCOUNTS = {
  authority: '0x7920ca01d3d1ac463dfd55b5ddfdcbb64ae31830f31be045ce2d51a305516a37',
  alice: '0xbb63b692f9d8f21f0b978b596dc2b8611899f053d68aec6c1c20d1df4f5b6ee2',
  bob: '0x2f615ea53711e0d91390e97cdd5ce97357e345e441aa95d255094164f44c8652',
  charlie: '0x7d52c3f6477e1507d54a826833169ad169a56e02ffc49a1801218a7d87ca50bd',
  dan: '0x6aecd44fcb79d4b68f1ee2b2c706f8e9a0cd06b0de4729fe98cfed8886315256',
  mallory: '0x686e245584fdf696abd739c0e66ac6e01fc4c68babee20c7124566e118b2a634',
  eve: '0x9fd4ab25e1699bb252f4d5c4510a135db34b3adca8baa03194ad5cd6faa13a1d',
  trudy: '0xe8445efa4e3349c3c74fd6689553f93b55aca723115fb777e1e6f4db2a0a82ca'
}

// All the contracts are expected to have been deployed to Ganache when this function is called.
function setupContracts(): { cards: EthCardsContract } {
  web3 = new Web3('http://localhost:8545')
  const abi = require('./contracts/cards-abi.json')
  const cards = new EthCardsContract(new web3.eth.Contract(abi, ADDRESSES.token_contract))
  return { cards }
}

interface IPlasmaDeposit {
  slot: BN
  blockNumber: BN
  denomination: BN
  from: string
}

class EthCardsContract extends EthErc721Contract {
  registerAsync(address: string): Promise<object> {
    return this.contract.methods.register().send({ from: address, gas: DEFAULT_GAS })
  }

  depositToPlasmaAsync(params: { tokenId: BN | number; from: string }): Promise<object> {
    const { tokenId, from } = params
    return this.contract.methods.depositToPlasma(tokenId).send({ from, gas: DEFAULT_GAS })
  }
}

class Entity {
  // web3 account
  private _ethAccount: any // TODO: type this properly
  private _dAppPlasmaClient: DAppChainPlasmaClient
  private _ethPlasmaClient: EthereumPlasmaClient

  get ethAddress(): string {
    return this._ethAccount.address
  }

  get plasmaCashContract(): any {
    return this._ethPlasmaClient.plasmaCashContract
  }

  constructor(ethPrivateKey: string) {
    this._ethAccount = web3.eth.accounts.privateKeyToAccount(ethPrivateKey)
    this._ethPlasmaClient = new EthereumPlasmaClient(web3, ADDRESSES.root_chain)

    const dAppClient = createTestHttpClient()
    // TODO: move keys to config file
    const privKey = CryptoUtils.generatePrivateKey()
    const pubKey = CryptoUtils.publicKeyFromPrivateKey(privKey)
    dAppClient.txMiddleware = [
      new NonceTxMiddleware(pubKey, dAppClient),
      new SignedTxMiddleware(privKey)
    ]
    const callerAddress = new Address('default', LocalAddress.fromPublicKey(pubKey))
    this._dAppPlasmaClient = new DAppChainPlasmaClient({ dAppClient, callerAddress })
  }

  async transferTokenAsync(params: {
    slot: BN
    prevBlockNum: BN
    denomination: BN | number
    newOwner: Entity
  }) {
    const { slot, prevBlockNum, denomination, newOwner } = params
    const tx = new PlasmaCashTx({
      slot,
      prevBlockNum,
      denomination,
      newOwner: newOwner.ethAddress
    })
    await tx.signAsync(new Web3Signer(web3, this.ethAddress))
    await this._dAppPlasmaClient.sendTxAsync(tx)
  }

  async submitPlasmaBlockAsync(): Promise<BN> {
    await this._dAppPlasmaClient.debugFinalizeBlockAsync()
    const blockNum = await this._dAppPlasmaClient.getCurrentPlasmaBlockNumAsync()
    const block = await this._dAppPlasmaClient.getPlasmaBlockAtAsync(blockNum)
    await this._ethPlasmaClient.debugSubmitBlockAsync({ block, from: this.ethAddress })
    return blockNum
  }

  async startExitAsync(params: { slot: BN; prevBlockNum: BN; exitBlockNum: BN }): Promise<object> {
    const { slot, prevBlockNum, exitBlockNum } = params

    // In case the sender is exiting a Deposit transaction, they should just create a signed
    // transaction to themselves. There is no need for a merkle proof.
    if (exitBlockNum.modn(CHILD_BLOCK_INTERVAL) !== 0) {
      const exitTx = new PlasmaCashTx({
        slot,
        prevBlockNum: new BN(0),
        denomination: 1,
        newOwner: this.ethAddress
      })
      await exitTx.signAsync(new Web3Signer(web3, this.ethAddress))
      return this._ethPlasmaClient.startExitAsync({
        slot,
        exitTx,
        exitBlockNum,
        from: this.ethAddress,
        gas: DEFAULT_GAS
      })
    }

    // Otherwise, they should get the raw tx info from the blocks, and the merkle proofs.
    const exitBlock = await this._dAppPlasmaClient.getPlasmaBlockAtAsync(exitBlockNum)
    const exitTx = await exitBlock.findTxWithSlot(slot)
    if (!exitTx) {
      throw new Error(`Invalid exit block: missing tx for slot ${slot.toString(10)}.`)
    }
    const prevBlock = await this._dAppPlasmaClient.getPlasmaBlockAtAsync(prevBlockNum)
    const prevTx = await prevBlock.findTxWithSlot(slot)
    if (!prevTx) {
      throw new Error(`Invalid prev block: missing tx for slot ${slot.toString(10)}.`)
    }
    return this._ethPlasmaClient.startExitAsync({
      slot,
      prevTx,
      exitTx,
      prevBlockNum,
      exitBlockNum,
      from: this.ethAddress,
      gas: DEFAULT_GAS
    })
  }
}

function marshalDepositEvent(data: {
  slot: string
  blockNumber: string
  denomination: string
  from: string
}): IPlasmaDeposit {
  const { slot, blockNumber, denomination, from } = data
  return {
    slot: new BN(slot),
    blockNumber: new BN(blockNumber),
    denomination: new BN(denomination),
    from
  }
}

test('Plasma Cash Demo', async t => {
  const { cards } = setupContracts()
  const authority = new Entity(ACCOUNTS.authority)
  const alice = new Entity(ACCOUNTS.alice)

  await cards.registerAsync(alice.ethAddress)
  let balance = await cards.balanceOfAsync(alice.ethAddress)
  t.equal(balance.toNumber(), 5)

  const startBlockNum = await web3.eth.getBlockNumber()

  for (let i = 0; i < ALICE_DEPOSITED_COINS; i++) {
    await cards.depositToPlasmaAsync({ tokenId: COINS[i], from: alice.ethAddress })
  }

  const depositEvents: any[] = await authority.plasmaCashContract.getPastEvents('Deposit', {
    fromBlock: startBlockNum
  })
  const deposits = depositEvents.map<IPlasmaDeposit>(event =>
    marshalDepositEvent(event.returnValues)
  )
  t.equal(deposits.length, ALICE_DEPOSITED_COINS, 'All deposit events accounted for')
  for (let i = 0; i < deposits.length; i++) {
    const deposit = deposits[i]
    t.equal(deposit.blockNumber.toNumber(), i + 1, `Deposit ${i + 1} block number is correct`)
    t.equal(deposit.denomination.toNumber(), 1, `Deposit ${i + 1} denomination is correct`)
    t.equal(deposit.from, alice.ethAddress, `Deposit ${i + 1} sender is correct`)
  }

  balance = await cards.balanceOfAsync(alice.ethAddress)
  t.equal(
    balance.toNumber(),
    ALICE_INITIAL_COINS - ALICE_DEPOSITED_COINS,
    'alice should have 2 tokens in cards contract'
  )
  balance = await cards.balanceOfAsync(ADDRESSES.root_chain)
  t.equal(
    balance.toNumber(),
    ALICE_DEPOSITED_COINS,
    'plasma contract should have 3 tokens in cards contract'
  )

  // Alice to Bob, and Alice to Charlie. We care about the Alice to Bob
  // transaction
  const bob = new Entity(ACCOUNTS.bob)
  const charlie = new Entity(ACCOUNTS.charlie)
  const deposit3 = deposits[2]
  const deposit2 = deposits[1]
  // Alice -> Bob
  await alice.transferTokenAsync({
    slot: deposit3.slot,
    prevBlockNum: deposit3.blockNumber,
    denomination: 1,
    newOwner: bob
  })
  // Alice -> Charlie
  await alice.transferTokenAsync({
    slot: deposit2.slot,
    prevBlockNum: deposit2.blockNumber,
    denomination: 1,
    newOwner: charlie
  })
  const plasmaBlockNum1 = await authority.submitPlasmaBlockAsync()
  // Add an empty block in between (for proof of exclusion)
  await authority.submitPlasmaBlockAsync()
  // Bob -> Charlie
  await bob.transferTokenAsync({
    slot: deposit3.slot,
    prevBlockNum: new BN(1000),
    denomination: 1,
    newOwner: charlie
  })

  // TODO: get coin history of deposit3.slot from bob
  // TODO: charlie should verify coin history of deposit3.slot

  const plasmaBlockNum2 = await authority.submitPlasmaBlockAsync()

  // TODO: charlie should watch exits of deposit3.slot

  await charlie.startExitAsync({
    slot: deposit3.slot,
    prevBlockNum: plasmaBlockNum1,
    exitBlockNum: plasmaBlockNum2
  })

  // TODO: charlie should stop watching exits of deposit3.slot

  // TODO: Jump forward in time by 8 days
  // TODO: authority should finalize exits
  // TODO: charlie should withdraw deposit3.slot

  balance = await cards.balanceOfAsync(alice.ethAddress)
  t.equal(balance.toNumber(), 2, 'alice should have 2 tokens in cards contract')
  balance = await cards.balanceOfAsync(bob.ethAddress)
  t.equal(balance.toNumber(), 0, 'bob should have no tokens in cards contract')
  balance = await cards.balanceOfAsync(charlie.ethAddress)
  t.equal(balance.toNumber(), 1, 'charlie should have 1 token in cards contract')

  t.end()
})
